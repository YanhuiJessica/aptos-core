
Diagnostics:
warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:19:22
   │
19 │             i = i + 1;
   │                      ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:46:22
   │
46 │             i = i + 1;
   │                      ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:47:10
   │
47 │         };
   │          ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:56:22
   │
56 │             i = i + 1;
   │                      ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:57:10
   │
57 │         };
   │          ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:64:22
   │
64 │             i = i + 1;
   │                      ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:65:10
   │
65 │         };
   │          ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:71:27
   │
71 │         guess_flips(flips);
   │                           ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:77:36
   │
77 │         guess_flips_directly(flips);
   │                                    ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:83:47
   │
83 │         guess_with_break_without_inline(flips);
   │                                               ^

warning: A trailing `;` in an expression block implicitly adds a `()` value expression after the semicolon, not needed here.
   ┌─ tests/checking/inlining/bug_9717.move:89:47
   │
89 │         guess_without_break_with_inline(flips);
   │                                               ^

// -- Model dump before bytecode pipeline
module 0xcafe::vectors {
    use std::vector;
    public entry fun guess_flips(flips: vector<u8>) {
        {
          let (flips: &vector<u8>): (&vector<u8>) = Tuple(Borrow(Immutable)(flips));
          {
            let i: u64 = 0;
            loop {
              if Lt<u64>(i, vector::length<u8>(flips)) {
                if Neq<u8>(Deref(vector::borrow<u8>(flips, i)), 0) {
                  break
                } else {
                  Tuple()
                };
                i: u64 = Add<u64>(i, 1);
                Tuple()
              } else {
                break
              }
            };
            Tuple()
          }
        };
        {
          let _v: vector<u8> = Copy(flips);
          {
            let _v2: vector<u8> = flips;
            Tuple()
          }
        }
    }
    public entry fun guess_flips_directly(flips: vector<u8>) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<u8>(Borrow(Immutable)(flips))) {
              if Neq<u8>(Deref(vector::borrow<u8>(Borrow(Immutable)(flips), i)), 0) {
                break
              } else {
                Tuple()
              };
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          };
          {
            let _v: vector<u8> = Copy(flips);
            {
              let _v2: vector<u8> = flips;
              Tuple()
            }
          }
        }
    }
    public entry fun guess_with_break_without_inline(flips: vector<u8>) {
        vectors::loops_with_break_no_inline(Borrow(Immutable)(flips));
        {
          let _v: vector<u8> = Copy(flips);
          {
            let _v2: vector<u8> = flips;
            Tuple()
          }
        }
    }
    public entry fun guess_without_break_with_inline(flips: vector<u8>) {
        {
          let (flips: &vector<u8>): (&vector<u8>) = Tuple(Borrow(Immutable)(flips));
          {
            let i: u64 = 0;
            loop {
              if Lt<u64>(i, vector::length<u8>(flips)) {
                if Eq<u8>(Deref(vector::borrow<u8>(flips, i)), 0) {
                  Tuple()
                } else {
                  Abort(3)
                };
                i: u64 = Add<u64>(i, 1);
                Tuple()
              } else {
                break
              }
            };
            Tuple()
          }
        };
        {
          let _v: vector<u8> = flips;
          {
            let _v2: vector<u8> = Copy(flips);
            Tuple()
          }
        }
    }
    private inline fun loops_with_break(flips: &vector<u8>) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<u8>(flips)) {
              if Neq<u8>(Deref(vector::borrow<u8>(flips, i)), 0) {
                break
              } else {
                Tuple()
              };
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          };
          Tuple()
        }
    }
    private fun loops_with_break_no_inline(flips: &vector<u8>) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<u8>(flips)) {
              if Neq<u8>(Deref(vector::borrow<u8>(flips, i)), 0) {
                break
              } else {
                Tuple()
              };
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          };
          Tuple()
        }
    }
    private inline fun loops_without_break(flips: &vector<u8>) {
        {
          let i: u64 = 0;
          loop {
            if Lt<u64>(i, vector::length<u8>(flips)) {
              if Eq<u8>(Deref(vector::borrow<u8>(flips, i)), 0) {
                Tuple()
              } else {
                Abort(3)
              };
              i: u64 = Add<u64>(i, 1);
              Tuple()
            } else {
              break
            }
          };
          Tuple()
        }
    }
    private fun test_guess_directly() {
        vectors::guess_flips_directly([Number(0), Number(0), Number(0), Number(0)]);
        Tuple()
    }
    private fun test_guess_with_break_no_inline() {
        vectors::guess_with_break_without_inline([Number(0), Number(0), Number(0), Number(0)]);
        Tuple()
    }
    private fun test_guess_with_inline_break() {
        vectors::guess_flips([Number(0), Number(0), Number(0), Number(0)]);
        Tuple()
    }
    private fun test_guess_without_break() {
        vectors::guess_without_break_with_inline([Number(0), Number(0), Number(0), Number(0)]);
        Tuple()
    }
} // end 0xcafe::vectors


============ bytecode verification succeeded ========
